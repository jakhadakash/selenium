# Generated by Selenium IDE - Modified with robust error handling
import pytest
import time
import os
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
import os
from selenium.common.exceptions import (
  TimeoutException,
  NoSuchElementException,
  StaleElementReferenceException,
  ElementClickInterceptedException,
)

class TestUntitled():
  def setup_method(self, method):
    # Chrome setup
    self.driver = webdriver.Chrome()
    # By default, position the browser on the right half of the screen
    # to keep it visible but not fullscreen. Set FULLSCREEN=1 to override.
    try:
      if os.environ.get("FULLSCREEN"):
        self.driver.maximize_window()
      else:
        screen_width = self.driver.execute_script("return window.screen.width;")
        screen_height = self.driver.execute_script("return window.screen.height;")
        half_width = int(screen_width) // 2
        # Position at the right half of the screen
        self.driver.set_window_position(half_width, 0)
        self.driver.set_window_size(half_width, int(screen_height))
    except Exception:
      # Fallback to maximize if screen metrics are unavailable
      try:
        self.driver.maximize_window()
      except Exception:
        pass
    self.vars = {}
    
    # Load test data from JSON
    with open('test_data1.json', 'r') as f:
      self.test_data = json.load(f)
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def wait_and_click(self, by, value, timeout=10, retries=3, scroll=True):
    """Helper method to wait for element and click with retry logic"""
    # Normalize selector string for JS fallbacks
    selector_str = None
    if by == By.CSS_SELECTOR:
      selector_str = value
    elif by == By.ID:
      selector_str = f"#{value}"

    for attempt in range(retries):
      try:
        # Wait for presence and visibility before checking clickability
        WebDriverWait(self.driver, timeout).until(
          EC.presence_of_element_located((by, value))
        )
        element = WebDriverWait(self.driver, timeout).until(
          EC.element_to_be_clickable((by, value))
        )

        # Scroll element into view
        if scroll:
          try:
            self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", element)
            time.sleep(0.3)
          except Exception:
            pass

        # Try robust click strategies
        try:
          # JS click first (works around many overlay issues)
          self.driver.execute_script("arguments[0].click();", element)
          return element
        except ElementClickInterceptedException:
          # If intercepted, try to click via document.querySelector (when we have a CSS selector)
          if selector_str:
            try:
              self.driver.execute_script("document.querySelector(arguments[0]).click();", selector_str)
              return self.driver.find_element(by, value)
            except Exception:
              pass
          # Try clicking the element normally as a fallback
          try:
            element.click()
            return element
          except Exception:
            raise
        except Exception:
          # Fallback to normal click if JS fails for other reasons
          element.click()
          return element
      except StaleElementReferenceException:
        if attempt == retries - 1:
          raise
        time.sleep(1)
      except TimeoutException:
        # On timeout, try a small wait and retry (to handle dynamic content)
        if attempt == retries - 1:
          # Let caller handle the exception; but capture diagnostics here
          self._save_debug_artifacts(f"click-{value}")
          raise
        time.sleep(1)

  def _save_debug_artifacts(self, name_prefix="debug"):
    """Save screenshot and HTML page source to debug_artifacts/ with timestamp"""
    try:
      ts = time.strftime('%Y%m%d-%H%M%S')
      debug_dir = os.path.join(os.path.dirname(__file__), "debug_artifacts")
      os.makedirs(debug_dir, exist_ok=True)
      screenshot = os.path.join(debug_dir, f"{name_prefix}-{ts}.png")
      page_file = os.path.join(debug_dir, f"{name_prefix}-{ts}.html")
      try:
        self.driver.save_screenshot(screenshot)
      except Exception as e:
        print(f"Failed to save screenshot: {e}", flush=True)
      try:
        with open(page_file, "w", encoding="utf-8") as fh:
          fh.write(self.driver.page_source)
      except Exception as e:
        print(f"Failed to save page source: {e}", flush=True)
      print(f"Saved debug artifacts: {screenshot}, {page_file}", flush=True)
    except Exception as e:
      print(f"Failed to create debug artifacts: {e}", flush=True)
  
  def wait_and_send_keys(self, by, value, keys, timeout=10, retries=3):
    """Helper method to wait for element and send keys with retry logic"""
    for attempt in range(retries):
      try:
        element = WebDriverWait(self.driver, timeout).until(
          EC.presence_of_element_located((by, value))
        )
        element.clear()
        element.send_keys(keys)
        return element
      except StaleElementReferenceException:
        if attempt == retries - 1:
          raise
        time.sleep(1)
  
  def test_untitled(self):
    # Test name: Untitled
    print("Starting test...")
    
    # 1 | open | https://www.tangerine.com.au/nbn/nbn-broadband | 
    print("Step 1: Opening website...")
    self.driver.get("https://www.tangerine.com.au/nbn/nbn-broadband")
    time.sleep(3)
    
    # 2 | type | id=autocomplete | 333 George St, BRISBANE CITY QLD, 4000
    print("Step 2: Entering address...")
    self.wait_and_send_keys(By.ID, "autocomplete", self.test_data["address"])
    time.sleep(3)  # Wait for autocomplete dropdown to populate
    
    # 3 | clickAt | css=.autocomplete-suggestion | 
    print("Step 3: Selecting autocomplete suggestion...")
    try:
      # Wait for suggestions to be visible
      WebDriverWait(self.driver, 10).until(
        EC.visibility_of_element_located((By.CSS_SELECTOR, ".autocomplete-suggestion"))
      )
      time.sleep(1)  # Small delay to ensure suggestions are stable
      
      # Try to click using different methods
      try:
        suggestion = self.driver.find_element(By.CSS_SELECTOR, ".autocomplete-suggestion")
        self.driver.execute_script("arguments[0].click();", suggestion)
        print("Clicked suggestion using JavaScript")
      except:
        suggestions = self.driver.find_elements(By.CSS_SELECTOR, ".autocomplete-suggestion")
        if suggestions:
          suggestions[0].click()
          print("Clicked first suggestion using Selenium")
    except (TimeoutException, NoSuchElementException, StaleElementReferenceException) as e:
      print(f"Autocomplete suggestion not found or stale: {e}")
      print("Pressing ENTER as fallback...")
      autocomplete_field = self.driver.find_element(By.ID, "autocomplete")
      autocomplete_field.send_keys(Keys.ARROW_DOWN)
      time.sleep(0.5)
      autocomplete_field.send_keys(Keys.ENTER)
    time.sleep(3)
    
    # 4 | clickAt | linkText=Build Your Plan | 
    print("Step 4: Clicking Build Your Plan...")
    self.wait_and_click(By.LINK_TEXT, "Build Your Plan")
    time.sleep(3)
    
    # 5 | clickAt | id=75_speed | 
    print("Step 5: Selecting 75 speed...")
    self.wait_and_click(By.ID, "75_speed")
    time.sleep(2)
    
    # 5.5 | Click continue button on popup after plan selection
    print("Step 5.5: Clicking continue button on popup...")
    try:
      continue_btn = WebDriverWait(self.driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//*[@id='a2g_back_btn']"))
      )
      self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", continue_btn)
      time.sleep(0.5)
      self.driver.execute_script("arguments[0].click();", continue_btn)
      print("Popup continue button clicked successfully")
    except Exception as e:
      print(f"Continue button popup not found or already closed: {e}")
    time.sleep(2)
    
    # 6 | clickAt | Order Now button 
    print("Step 6: Clicking 'Order Now' button (address order not found)...")
    # Scroll to bottom of page to ensure element is visible
    self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
    time.sleep(1)
    
    try:
      # Try original CSS selector first
      try:
        self.wait_and_click(By.CSS_SELECTOR, ".mt-2 > #addressordernotfound")
        print("Order Now button clicked successfully", flush=True)
      except Exception:
        # Try by ID directly (more robust if layout changed)
        try:
          self.wait_and_click(By.ID, "addressordernotfound")
          print("Order Now button clicked using ID selector", flush=True)
        except Exception:
          # Try XPath fallback
          try:
            self.wait_and_click(By.XPATH, "//*[@id='addressordernotfound']")
            print("Order Now button clicked using XPath selector", flush=True)
          except Exception as e:
            print(f"Error clicking Order Now button after multiple attempts: {e}", flush=True)
            # Save debug artifacts for analysis
            try:
              self._save_debug_artifacts("order-now-fail")
            except Exception as _:
              pass
            raise
    except Exception as e:
      print(f"Error clicking Order Now button: {e}", flush=True)
      raise
    time.sleep(2)
    
    # 7 | clickAt | Agree and Continue using XPath
    print("Step 7: Clicking Agree and Continue...")
    try:
      # First try with the specific XPath
      agree_continue_btn = WebDriverWait(self.driver, 10).until(
        EC.element_to_be_clickable((By.XPATH, "//*[@id='modem-select-NBN-not-selected']/div/div[3]/div/a"))
      )
      self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", agree_continue_btn)
      time.sleep(0.5)
      self.driver.execute_script("arguments[0].click();", agree_continue_btn)
      print("Agree and Continue clicked using XPath")
    except Exception as e:
      print(f"XPath failed: {e}, trying link text...")
      # Fallback to link text
      self.wait_and_click(By.LINK_TEXT, "Agree and Continue")
    time.sleep(3)
    
    # 8 | type | id=login_email | rahul@cimet.com.au
    print("Step 8: Entering email...")
    self.wait_and_send_keys(By.ID, "login_email", self.test_data["email"])
    time.sleep(2)
    
    # 9 | clickAt | id=submit_email | 
    print("Step 9: Submitting email...")
    self.wait_and_click(By.ID, "submit_email")
    time.sleep(4)
    
    # 10 | clickAt | id=salutation | 
    print("Step 10: Clicking salutation...")
    self.wait_and_click(By.ID, "salutation")
    time.sleep(1)
    
    # 11 | type | id=fname | Saurabh
    print("Step 11: Entering first name...")
    self.wait_and_send_keys(By.ID, "fname", self.test_data["first_name"])
    time.sleep(1)
    
    # 12 | type | id=lname | Test
    print("Step 12: Entering last name...")
    self.wait_and_send_keys(By.ID, "lname", self.test_data["last_name"])
    time.sleep(1)
    
    # 13 | type | id=mobile | 0420580919
    print("Step 13: Entering mobile...")
    self.wait_and_send_keys(By.ID, "mobile", self.test_data["mobile"])
    time.sleep(1)
    
    # 14 & 15 | Set DOB using JavaScript to bypass calendar picker
    print("Step 14-15: Setting DOB...")
    try:
      dob_field = WebDriverWait(self.driver, 10).until(
        EC.presence_of_element_located((By.ID, "dob"))
      )
      
      # Method 1: Use JavaScript to set the value directly (bypasses calendar)
      self.driver.execute_script("arguments[0].value = arguments[1];", dob_field, self.test_data['dob'])
      
      # Trigger change event to ensure validation
      self.driver.execute_script("arguments[0].dispatchEvent(new Event('change', { bubbles: true }));", dob_field)
      self.driver.execute_script("arguments[0].dispatchEvent(new Event('input', { bubbles: true }));", dob_field)
      
      time.sleep(1)
    except Exception as e:
      print(f"Error setting DOB: {e}")
      # Fallback to regular input method
      self.wait_and_click(By.ID, "dob")
      time.sleep(0.5)
      self.wait_and_send_keys(By.ID, "dob", self.test_data["dob"])
      time.sleep(1)
    
    # 16 | select | id=hear_about_us | --Other--
    print("Step 16: Selecting hear about us...")
    for attempt in range(3):
      try:
        dropdown = WebDriverWait(self.driver, 10).until(
          EC.presence_of_element_located((By.ID, "hear_about_us"))
        )
        dropdown.find_element(By.XPATH, "//option[. = '--Other--']").click()
        break
      except StaleElementReferenceException:
        if attempt == 2:
          raise
        time.sleep(1)
    time.sleep(1)
    
    # 17 | clickAt | css=.custom-control-label:nth-child(3) | 
    print("Step 17: Clicking custom control label...")
    self.wait_and_click(By.CSS_SELECTOR, ".custom-control-label:nth-child(3)")
    time.sleep(1)
    
    # 18 | clickAt | css=.contactnext | 
    print("Step 18: Clicking contact next...")
    self.wait_and_click(By.CSS_SELECTOR, ".contactnext")
    time.sleep(3)
    
    # 19 | clickAt | id=btn-address-transfer | 
    print("Step 19: Clicking address transfer...")
    self.wait_and_click(By.ID, "btn-address-transfer")
    time.sleep(2)
    
    # 20 | clickAt | id=btn-transfer-number | 
    print("Step 20: Clicking transfer number...")
    self.wait_and_click(By.ID, "btn-transfer-number")
    time.sleep(2)
    
    # 21 | clickAt | id=donate-no | 
    print("Step 21: Clicking donate no...")
    self.wait_and_click(By.ID, "donate-no")
    time.sleep(2)
    
    # 22 | clickAt | id=btn-address-transfer | 
    print("Step 22: Final address transfer click...")
    self.wait_and_click(By.ID, "btn-address-transfer")
    time.sleep(3)
    
    print("âœ… Test completed successfully!")